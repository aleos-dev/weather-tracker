### Обзор проекта

Одна из главных целей этого проекта — ознакомиться с работой **`HttpSession`** и управлением **`Cookie`**. Чтобы расширить это понимание, я решил реализовать упрощённую версию **Security Filter Chain**, вдохновлённую подходом Spring Security.

### Ключевые компоненты и рабочий процесс

1. **DelegatingFilterProxy**:
   - **`DelegatingFilterProxy`** — это фильтр, зарегистрированный в контексте Tomcat, который делегирует запрос бину **`SecurityFilterChain`**, управляемому **`BeanFactory`**. Это позволяет модульно обрабатывать фильтры безопасности в цепочке фильтров, аналогично тому, как это делает **`FilterChainProxy`** в Spring Security.

2. **DefaultSecurityFilterChain**:
   - Этот класс отвечает за хранение и выполнение серии фильтров, связанных с безопасностью.
   - Он создается с помощью **`SecurityInitializer`** и настраивается через **`SecurityFilterChainConfigurer`**. После настройки он добавляется в **`ApplicationContext`**, представленный **`BeanFactory`**.
   - **`BeanFactory`** использует Java-класс конфигурации, **`ApplicationContextConfiguration`**, для создания и управления "бинами". Эти бины хранятся в **`ServletContext`** с помощью **`ApplicationContextInitializer`**, который реализует интерфейс **`ServletContextListener`**.

### Реализованные фильтры

На данный момент я реализовал несколько ключевых фильтров:

1. **SecurityContextHolderFilter**:
   - Этот фильтр работает с **`SecurityContext`**. Он либо создает новый **`SecurityContext`**, либо извлекает существующий из объекта **`HttpSession`**, который ранее был обработан **`SessionFilter`**.
   - **`SecurityContext`** хранит информацию о текущем аутентифицированном пользователе. Чтобы имитировать отложенную загрузку (как в Spring), этот фильтр использует класс **`SingletonSupplier`**, который откладывает загрузку контекста до момента, когда он действительно понадобится.

2. **AuthenticationFilter**:
   - Этот фильтр отвечает за управление логикой аутентификации, проверяя учетные данные и устанавливая аутентифицированного пользователя в контексте безопасности.

3. **AnonymousAuthenticationFilter**:
   - **`AnonymousAuthenticationFilter`** проверяет, связан ли текущий запрос с аутентифицированным пользователем. Если в **`SecurityContext`** не найдено аутентификации, фильтр назначает **анонимного** пользователя, чтобы система могла обрабатывать неаутентифицированный доступ в контролируемом режиме.

4. **AuthorizationFilter**:
   - **`AuthorizationFilter`** использует **`AuthorizationManager`**, чтобы проверить, есть ли у текущего аутентифицированного пользователя необходимые роли для доступа к определенному URL. Правила авторизации хранятся в карте внутри **`AuthorizationManager`**, которая сопоставляет шаблоны URL с требуемыми ролями.

### Вспомогательные классы

1. **SessionManager**:
   - Этот класс управляет всеми взаимодействиями с объектом **`HttpSession`**, обрабатывая создание сессий, их истечение и данные пользователей. Он также управляет **`Cookie`**, в котором хранится идентификатор сессии. На данном этапе управление куки всё ещё обрабатывается напрямую внутри этого класса, так как пока не было необходимости выносить его в отдельный класс.

2. **SingletonSupplier**:
   - **`SingletonSupplier`** гарантирует, что **`SecurityContext`** загружается лениво и только один раз, даже если несколько запросов пытаются получить к нему доступ одновременно. Это имитирует поведение ленивой загрузки, которое используется в Spring Security для обработки контекста.

3. **ApplicationContext**:
   - Управляемый через **`BeanFactory`**, он служит основным контейнером, где создаются и внедряются различные бины (например, `SessionManager`, `SecurityContextRepository`, `AuthorizationManager`) в цепочку фильтров.
